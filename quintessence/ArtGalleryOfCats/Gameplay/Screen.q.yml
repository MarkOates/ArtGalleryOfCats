parent_classes:


  - class: AllegroFlare::Screens::Base
    scope: public
    init_with: ArtGalleryOfCats::Gameplay::Screen::TYPE


properties:


  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true

  - name: model_bin
    type: AllegroFlare::ModelBin*
    init_with: nullptr
    constructor_arg: true

  - name: resources_path
    type: std::string
    init_with: DEFAULT_RESOURCES_PATH
    constructor_arg: true

  - name: user_text_input_screen
    type: ArtGalleryOfCats::Screens::UserTextInput*
    init_with: nullptr
    constructor_arg: true

  - name: npc_conversations_screen
    type: AllegroFlare::Screens::Storyboard*
    init_with: nullptr
    constructor_arg: true

  - name: solved_level_names
    type: std::set<std::string>*
    init_with: nullptr
    constructor_arg: true

  - name: dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: true
    setter: true

  - name: riddle_is_solved
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: riddle_is_showing
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: inspect_hint_is_showing
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: last_user_text_input_value
    type: std::string
    init_with: '""'
    getter: true
    setter: true

  - name: current_level_identifier
    type: std::string
    init_with: '"[unset-current_level]"'

  - name: current_level
    type: ArtGalleryOfCats::Gameplay::Level*
    init_with: nullptr

  - name: player_velocity
    type: AllegroFlare::Vec2D
    init_with: '{}'

  - name: player_right_pressed
    type: bool
    init_with: false

  - name: player_left_pressed
    type: bool
    init_with: false

  - name: player_up_pressed
    type: bool
    init_with: false

  - name: player_down_pressed
    type: bool
    init_with: false

  - name: entity_player_is_currently_colliding_with
    type: AllegroFlare::SceneGraph::Entities::Base*
    init_with: nullptr
    getter: true
    setter: true

  - name: on_finished_callback_func
    type: std::function<void(ArtGalleryOfCats::Gameplay::Screen*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: on_finished_callback_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: cubemap_shader
    type: AllegroFlare::Shaders::Cubemap
    init_with: '{}'

  - name: cubemap
    type: AllegroFlare::Cubemap*
    init_with: nullptr

  - name: HACK_sysname
    type: std::string
    init_with: DEFAULT_HACK_SYSNAME
    getter: true

  - name: initialized
    type: bool
    init_with: false

  - name: TYPE
    type: char*
    init_with: '(char*)"ArtGalleryOfCats/Gameplay/Screen"'
    static: true
    constexpr: true

  - name: DEFAULT_RESOURCES_PATH
    type: char*
    init_with: '(char*)"[unset-resources_path]"'
    static: true
    constexpr: true

  - name: DEFAULT_HACK_SYSNAME
    type: char*
    init_with: '(char*)"[unset-HACK_sysname]"'
    static: true
    constexpr: true


functions:


  - name: set_event_emitter
    guards: [ (!initialized) ]
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    body: |
      this->event_emitter = event_emitter;
      return;


  - name: set_bitmap_bin
    guards: [ (!initialized) ]
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    body: |
      this->bitmap_bin = bitmap_bin;
      return;


  - name: set_font_bin
    guards: [ (!initialized) ]
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    body: |
      this->font_bin = font_bin;
      return;


  - name: set_model_bin
    guards: [ (!initialized) ]
    parameters:
      - name: model_bin
        type: AllegroFlare::ModelBin*
        default_argument: nullptr
    body: |
      this->model_bin = model_bin;
      return;


  - name: set_resources_path
    guards: [ (!initialized) ]
    parameters:
      - name: resources_path
        type: std::string
        default_argument: DEFAULT_RESOURCES_PATH
    body: |
      this->resources_path = resources_path;
      return;


  - name: set_user_text_input_screen
    guards: [ (!initialized) ]
    parameters:
      - name: user_text_input_screen
        type: ArtGalleryOfCats::Screens::UserTextInput*
        default_argument: nullptr
    body: |
      this->user_text_input_screen = user_text_input_screen;
      return;


  - name: set_npc_conversations_screen
    guards: [ (!initialized) ]
    parameters:
      - name: npc_conversations_screen
        type: AllegroFlare::Screens::Storyboard*
        default_argument: nullptr
    body: |
      this->npc_conversations_screen = npc_conversations_screen;
      return;


  - name: set_solved_level_names
    guards: [ (!initialized) ]
    parameters:
      - name: solved_level_names
        type: std::set<std::string>*
        default_argument: nullptr
    body: |
      this->solved_level_names = solved_level_names;
      return;


  - name: set_HACK_sysname
    guards: [ (!initialized) ]
    parameters:
      - name: HACK_sysname
        type: std::string
        default_argument: DEFAULT_HACK_SYSNAME
    body: |
      this->HACK_sysname = HACK_sysname;
      return;


  - name: load_level_by_identifier
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    body: |
      // Destroy the current level (if one exists)
      if (current_level)
      {
         std::cout << "INFO: Destroying current level" << std::endl;
         current_level->destroy(); // TODO: Make sure this is implemented
         delete (int*)(current_level);
         current_level = nullptr;
         current_level_identifier = "[no-current_level_identifier]";
      }

      // Create a new Level object, and make it the "current_level"
      current_level = new ArtGalleryOfCats::Gameplay::Level;
      current_level_identifier = level_identifier;

      // Load the level
      // TODO: Pass new level class properties into factory

      ArtGalleryOfCats::Gameplay::LevelFactory level_factory;
      level_factory.set_model_bin(model_bin);
      level_factory.set_bitmap_bin(bitmap_bin);
      level_factory.set_entity_pool(get_entity_pool());
      level_factory.set_riddle(get_current_riddle());
      level_factory.set_level(current_level);
      level_factory.set_resources_path(resources_path);


      std::map<std::string, std::function<void()>> items_map = {
         { "gallery_01", [this, &level_factory](){
            level_factory.load_gallery_01();
         }},
         { "gallery_02", [this, &level_factory](){
            // TODO: Replace this with new map
            level_factory.load_gallery_02();
         }},
         { "gallery_03", [this, &level_factory](){
            // TODO: Replace this with new map
            level_factory.load_gallery_03();
         }},
      };


      // locate and call the function to handle the item
      if (items_map.count(level_identifier) == 0)
      {
         // item not found
         std::stringstream error_message;
         error_message << "[CubeShooter::LevelFactory::load_level_by_identifier]: error: Cannot find item with the level_identifier\""
                       << level_identifier << "\", it does not exist.";
         throw std::runtime_error(error_message.str());
      }
      else
      {
         // call the item
         items_map[level_identifier]();
      }


      // TODO: Show gallery name (as "gallery_title")
      // TODO: Set the "riddle text"

      start_level_music();


      return;
    body_dependency_symbols:
      - ArtGalleryOfCats::Gameplay::LevelFactory


  - name: start_level_music
    body: |

      if (current_level->has_custom_music())
      {
         std::string custom_music_identifier = current_level->get_music_identifier();
         event_emitter->emit_play_music_track_event(custom_music_identifier);
      }
      else
      {
         std::string default_music_identifier = "main_music";
         event_emitter->emit_play_music_track_event(default_music_identifier);
      }
      return;


  - name: emit_event_to_set_input_hints_bar_to_room_controls
    private: true
    guards: [ initialized ]
    body: |
      event_emitter->emit_set_input_hints_bar_event({
         "UP", "%SPACE", "DOWN", "%SPACE", "LEFT", "%SPACE", "RIGHT", "%SPACER", "LABEL>>", "Move pointer",
         "%SEPARATOR",
         "ENTER", "%SPACER", "LABEL>>", "Inspect object",
         "%SEPARATOR",
         "I", "%SPACER", "LABEL>>", "Toggle Chronicle",
         "%SEPARATOR",
         "P", "%SPACER", "LABEL>>", "Toggle pause",
         "%SEPARATOR",
         "E", "%SPACER", "LABEL>>", "Exit",
      });
      return;


  - name: emit_event_to_set_input_hints
    private: true
    guards: [ initialized ]
    body: |
      //if (fixed_room_2d.inventory_is_open()) emit_event_to_set_input_hints_bar_to_inventory_controls();
      else emit_event_to_set_input_hints_bar_to_room_controls();
      event_emitter->emit_set_input_hints_bar_text_opacity_event(0.265);
      return;


  - name: get_entity_pool
    type: AllegroFlare::SceneGraph::EntityPool*
    guards: [ current_level ]
    body: |
      // TODO: Add "guards: [ current_level ]"
      //return &entity_pool; // TODO: Swap this out with the current level entity_pool (comment below)
      return &current_level->get_entity_pool_ref();


  - name: get_current_riddle
    type: ArtGalleryOfCats::Gameplay::Riddle*
    guards: [ current_level ]
    body: |
      //return &current_riddle; // TODO: Swap this out with the current level entity_pool (comment below)
      return &current_level->get_current_riddle_ref();


  - name: initialize
    guards:
      - (!initialized)
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
      - al_is_font_addon_initialized()
      - event_emitter
      - bitmap_bin
      - font_bin
      - model_bin
      - solved_level_names
      - (resources_path != DEFAULT_RESOURCES_PATH)
      - (HACK_sysname != DEFAULT_HACK_SYSNAME)
    body: |
      // TODO: Fix this section
      AllegroFlare::CubemapBuilder builder;
      std::string cube_map_texture_filename = resources_path + "bitmaps/black_prism_1-01.png";
      //std::string cube_map_texture_filename = "fixtures/bitmaps/black_prism_1-01.png"; // TODO: set the correct location
      cubemap = builder.glsl_create_cubemap_from_vertical_strip(cube_map_texture_filename.c_str());

      cubemap_shader.initialize();
      cubemap_shader.set_cube_map(cubemap);

      load_dialog_node_bank();

      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized
      - AllegroFlare::CubemapBuilder


  - name: load_dialog_node_bank
    private: true
    body: |
      dialog_node_bank.set_nodes({

         // Riddle responses

         { "correct_riddle_answer", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "CORRECT!",
                 "You got it right! You are very attentive!",
                 "Nice sleuthing skills.",
                 "If you'd like, we can still look around this gallery.",
                 "Otherwise, we can move on to another gallery?",
                 //"If you'd like, you can still look around this gallery.",
                 "To go to another gallery, press the ESCAPE key while you're walking around.",
                 //"Or, just return to the Galary Select Screen by pressing the ESCAPE key.",
                 //"
              }
           )
         },
         { "incorrect_riddle_answer", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Hmm, that's not the correct answer to the riddle.", "That's ok! You can try as many times as you like." }
           )
         },

         // Default and fallback dialog

         { "fallback_dialog", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "That's interesting." }
            )
         },
         { "default_inspect_1", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "The artist has such a good sense of form and balance!" }
            )
         },
         { "default_inspect_2", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "I really like this art!" }
            )
         },
         { "default_inspect_3", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "This art is fantastic! It nourishes the spirit!" }
            )
         },
         { "default_inspect_4", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Works like this one are always a favorite of mine!" }
            )
         },
         { "default_inspect_5", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Such striking composition!" }
            )
         },
         { "default_inspect_6", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Hmm, an interesting work!" }
            )
         },

         // Special inspections (colorful cats)

         { "inspect_on_black_and_white_cats_art", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "This one is quite striking!", "The black and white creates such a strong contrast." }
            )
         },

         // Special inspections (humans exhibit)

         { "inspect_medium_statue", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                  "You know, the actual, proper pronunciation is quite different than how we say it.",
                  "It's true!  I actually studied pronunciation at Cat University.",
                  "The word is pronounced...",
                  "hheee... heeeeuu.... heeewwww",
                  "...eeewmons.",
                  "Yes! That's it! Hiewmons.",
                  "Anyway, the hoomans exibit is one of my favs.  What mystical creatures they are!"
              }
            )
         },
         { "inspect_feature_statue", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "Wow! This is our most special exhibit. The Exhibit of the Mystical Creature!",
                 "In this gallery, there's art featuring the most mythical creature of all, the human.",
                 "Unlike cats, their ears are on the side of their heads.",
                 "Weird!"
              }
            )
         },
         { "inspect_small_statues", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Since we don't have any hard evidence, we can only imagine what color their furr might be." }
            )
         },
         { "inspect_human_01", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "This depiction is just incredible. Stunning detail.",
                 "But... without furr... it's just so... naked-looking!",
                 "Eek!"
              }
            )
         },
         { "inspect_human_02", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "Here they are, depicted with their ears on the side of their head." }
            )
         },
         { "inspect_human_03", new AllegroFlare::DialogTree::Node(
              "Mittens",
              { "The hooman myths go back centuries!  All the way back to ancient times." }
            )
         },
         { "inspect_human_04", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "This one is brilliant.  We can only imagine what the mystical hooman creature is like.",
                 "And here's a cat, looking in the mirror, imagining a human...",
                 "... and WE'RE here... looking at this art...",
                 "Maybe there's a hooman, looking at us right now!",
                 "Haha! What a crazy notion!",
              }
            )
         },
         { "inspect_human_05", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "Of course our gallery would not be complete without this famous work,",
                 "The \"Vitruvian Hooman\" by Leonardo Meow Vinci."
              }
            )
         },
         { "inspect_cat_years_to_human_years", new AllegroFlare::DialogTree::Node(
              "Mittens",
              {
                 "Interesting fact! Hoomans are said to live much longer than us cats.",
                 "Up to almost 10 times longer!",
                 "Hmm...",
                 "I guess if I were a human, I'd be 25 years old."
              }
            )
         },

      });
      return;


  - name: activate_npc_dialog_by_identifier
    parameters:
      - name: dialog_node_identifier
        type: std::string
        default_argument: '"[unset-dialog_node_identifier]"'
    body: |
      if (!dialog_node_bank.node_exists_by_name(dialog_node_identifier))
      {
         std::cout << "!!!!!!!! missing dialog for node \"" << dialog_node_identifier << "\"." << std::endl;
         return;
      }

      // TODO: Erase the current npc dialog pages (delete them)

      // Get dialog pages from node
      AllegroFlare::DialogTree::Node* dialog_node = dialog_node_bank.find_node_by_name(dialog_node_identifier);
      std::vector<std::string> dialog_pages = dialog_node->get_pages();

      // Create storyboard pages from the dialog pages
      std::vector<AllegroFlare::Elements::StoryboardPages::Base *> storyboard_pages = {};
      storyboard_pages.reserve(dialog_pages.size());
      for (auto &dialog_page : dialog_pages)
      {
         storyboard_pages.push_back(create_image_page(dialog_page));
      }

      // Assign our new dialog pages to the npc_coversations storyboard
      npc_conversations_screen->get_storyboard_element_ref().set_pages(storyboard_pages);

      // Activate the npc_conversations_screen
      activate_npc_conversations_screen(); // DEVELOPMENT

      return;


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized, current_level ]
    body: |
      hide_riddle();
      hide_inspect_hint();

      if (riddle_is_solved)
      {
         // Note: NPC dialog, after solving the riddle, will return back to this screen.
         // TODO: Progress to the next level
         event_emitter->emit_game_event(AllegroFlare::GameEvent("riddle_is_solved"));
            //AllegroFlare::Routers::Standard::EVENT_ACTIVATE_SCREEN_BY_IDENTIFIER,
            //new AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier("user_text_input_screen")
         //);
      }

      bool need_to_handle_user_text_input = !last_user_text_input_value.empty();
      if (need_to_handle_user_text_input)
      {
         bool answer_is_correct = false;
         //std::cout << "*** Handle user input text \"" << last_user_text_input_value << "\"" << std::endl;

         // Evaluate if answer is correct, depending on the current riddle, and the player's last input
         answer_is_correct = get_current_riddle()->matches_answer(last_user_text_input_value);

         // Clear our copy of the user input
         last_user_text_input_value.clear();

         if (!answer_is_correct)
         {
            // TODO: Sort out what reaction should be when answer is incorrect
            // TODO: Set npc dialog to say "hmm, that's not correct"

            event_emitter->emit_play_sound_effect_event("wrong_answer");
            activate_npc_dialog_by_identifier("incorrect_riddle_answer");
         }
         else
         {
            // TODO: Sort out what reaction should be when answer is correct
            // TODO: Set npc dialog to say "That's correct! Nice job!"

            //activate_npc_dialog_by_identifier("correct_riddle_answer");

            event_emitter->emit_event(
               ALLEGRO_FLARE_EVENT_UNLOCK_ACHIEVEMENT,
               intptr_t(new std::string("solve_a_riddle"))
            );


            event_emitter->emit_play_sound_effect_event("right_answer");

            riddle_is_solved = true; // TODO: modify this on a master list

            solved_level_names->insert(current_level->get_name()); // HERE
            std::cout << "- Solved level names are now:" << std::endl;
            for (auto &solved_level_name : (*solved_level_names))
            {
               std::cout << "   - " << solved_level_name << std::endl;
            }


            activate_npc_dialog_by_identifier("correct_riddle_answer");

            //activate_npc_conversations_screen(); // DEVELOPMENT
         }
      }


      // Show our input hints
      show_input_hints();
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      hide_input_hints();
      return;


  - name: hide_input_hints
    body: |
      event_emitter->emit_hide_input_hints_bar_event();
      return;


  - name: show_input_hints
    body: |
      event_emitter->emit_set_input_hints_bar_event({
         "UP", "%SPACE", "DOWN", "%SPACE", "LEFT", "%SPACE", "RIGHT", "%SPACER", "LABEL>>", "Move",
         "%SEPARATOR",
         "MOUSE", "%SPACER", "LABEL>>", "Look",
         "%SEPARATOR",
         "R", "%SPACER", "LABEL>>", "Toggle the Riddle",
         "%SEPARATOR",
         "S", "%SPACER", "LABEL>>", "Solve the Riddle",
         "%SEPARATOR",
         "I", "%SPACER", "LABEL>>", "Inspect",
         "%SEPARATOR",
         "ESC", "%SPACER", "LABEL>>", "Return to Gallery Select",
      });
      //if (fixed_room_2d.inventory_is_open()) emit_event_to_set_input_hints_bar_to_inventory_controls();
      //else emit_event_to_set_input_hints_bar_to_room_controls();
      event_emitter->emit_set_input_hints_bar_text_opacity_event(0.265);
      //emit_event_to_set_input_hints();
      //event_emitter->emit_set_input_hints_bar_backfill_opacity_event(0.3);
      event_emitter->emit_set_input_hints_bar_text_opacity_event(1.0);
      event_emitter->emit_show_input_hints_bar_event();


  - name: update
    body: |
      // HACK
      static int grabber_caller_HACK = 0;
      grabber_caller_HACK--;
      if (grabber_caller_HACK < 0)
      {
         ALLEGRO_DISPLAY *current_display = al_get_current_display();
         al_grab_mouse(current_display);
         grabber_caller_HACK = 99;
      }
      
      scene_physics_updater();
      return;


  - name: calculate_strafe_xy
    type: AllegroFlare::Vec3D
    parameters:
      - name: spin
        type: float
        default_argument: 0.0f
      - name: displacement
        type: float
        default_argument: 0.0f
    body: |
      type: AllegroFlare::Vec3D result;
      AllegroFlare::Vec2D move_vec(cos(spin), sin(spin));
      result.x = move_vec.x * displacement;
      result.y = 0;
      result.z = move_vec.y * displacement;
      return result;
        

  - name: calculate_forward_back_xy
    type: AllegroFlare::Vec3D
    parameters:
      - name: spin
        type: float
        default_argument: 0.0f
      - name: displacement
        type: float
        default_argument: 0.0f
    body: |
      type: AllegroFlare::Vec3D result;
      AllegroFlare::Vec2D move_vec(-sin(spin), cos(spin));
      result.x = move_vec.x * displacement;
      result.y = 0;
      result.z = move_vec.y * displacement;
      return result;


  - name: find_primary_camera
    type: ArtGalleryOfCats::Gameplay::Entities::Camera3D*
    guards: [ get_entity_pool() ]
    body: |
      AllegroFlare::SceneGraph::Entities::Base *entity = nullptr;
      // Extract our out camera
      entity = get_entity_pool()->find_with_attribute("primary_camera");
      if (!entity) throw std::runtime_error("find_primary_camera: no camera present");
      ArtGalleryOfCats::Gameplay::Entities::Camera3D *as_camera =
         static_cast<ArtGalleryOfCats::Gameplay::Entities::Camera3D*>(entity);

      return as_camera;


  - name: find_collision_tile_map
    type: ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap*
    guards: [ get_entity_pool() ]
    body: |
      AllegroFlare::SceneGraph::Entities::Base *entity = nullptr;
      // Extract our out collision_tile_map
      entity = get_entity_pool()->find_with_attribute("collision_tile_map");
      if (!entity) throw std::runtime_error("no collision_tile_map present");
      ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap *as_collision_tile_map =
         static_cast<ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap*>(entity);

      return as_collision_tile_map;


  - name: update_entity_player_is_currently_colliding_with
    guards: [ get_entity_pool() ]
    body: |
      // TODO: Implement this function
      //entity_player_is_currently_colliding_with

      // Select all the entities that the player can collide with
      std::vector<AllegroFlare::SceneGraph::Entities::Base*> entities_player_can_interact_with =
         get_entity_pool()->select_A(ArtGalleryOfCats::Gameplay::EntityFlags::PLAYER_CAN_INTERACT);

      
      float player_hit_box_size = 2.75;
      float player_h_hit_box_size = player_hit_box_size * 0.5;
      AllegroFlare::Vec3D player_position = find_primary_camera()->get_placement_ref().position;
      AllegroFlare::Physics::AABB2D player_hit_box_2d(
         player_position.x - player_h_hit_box_size,
         player_position.z - player_h_hit_box_size,
         player_hit_box_size,
         player_hit_box_size,
         0,
         0
      );

      // Find the entity that the player, in this frame, is colliding with (find the first one)
      ArtGalleryOfCats::Gameplay::Entities::Base *found_colliding_entity = nullptr;
      for (auto &entity_player_can_interact_with : entities_player_can_interact_with)
      {
         ArtGalleryOfCats::Gameplay::Entities::Base *as_agc_entity =
            static_cast<ArtGalleryOfCats::Gameplay::Entities::Base*>(entity_player_can_interact_with);

         // TODO: do AABB2D collision against the player
         bool player_collides_with_this_entity = player_hit_box_2d.collides(&as_agc_entity->get_hit_box_2d_ref());
         //AllegroFlare::Placement3D &placement = as_agc_entity->get_placement_ref();
         if (player_collides_with_this_entity)
         {
            found_colliding_entity = as_agc_entity;
            break;
         }
      }

      if (found_colliding_entity != entity_player_is_currently_colliding_with)
      {
         // Assign the found entity to be the colliding one
         entity_player_is_currently_colliding_with = found_colliding_entity;

         // TODO: Some feedback that a new collision occurred (a sound effect for example)
         if (entity_player_is_currently_colliding_with == nullptr)
         {
            hide_inspect_hint();
         }
         else
         {
            show_inspect_hint();
            //interact_with_focused_object(); // DEVELOPMENT
         }
      }

      return;
    body_dependency_symbols:
      - ArtGalleryOfCats::Gameplay::EntityFlags
        

  - name: scene_physics_updater
    private: true
    guards: [ get_entity_pool() ]
    body: |
      AllegroFlare::SceneGraph::Entities::Base *entity = nullptr;

      // Extract our out camera
      ArtGalleryOfCats::Gameplay::Entities::Camera3D* as_camera = find_primary_camera();

      // Update our camera velocity to match the "player_velocity"
      player_velocity = infer_player_velocity_from_keypress();
      AllegroFlare::Vec3D camera_strafe_speed = calculate_strafe_xy(as_camera->spin, player_velocity.x);
      AllegroFlare::Vec3D camera_forward_back_speed = calculate_forward_back_xy(as_camera->spin, player_velocity.y);
      as_camera->get_velocity_ref().position = camera_strafe_speed + camera_forward_back_speed;

      // Extract out the collision map
      ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap* as_collision_tile_map = find_collision_tile_map();

      // Create our collision stepper
      AllegroFlare::Physics::TileMapCollisionStepper collision_stepper;
      collision_stepper.set_collision_tile_map(&as_collision_tile_map->get_collision_tile_map_ref());
      collision_stepper.set_tile_width(1);
      collision_stepper.set_tile_height(1);

      float box_size = 1.4;
      float box_h_size = box_size * 0.5f;
      for (auto &entity : get_entity_pool()->get_entity_pool_ref())
      {
         ArtGalleryOfCats::Gameplay::Entities::Base *as_agc_entity =
            static_cast<ArtGalleryOfCats::Gameplay::Entities::Base*>(entity);
         AllegroFlare::Placement3D &placement = as_agc_entity->get_placement_ref();
         AllegroFlare::Placement3D &velocity = as_agc_entity->get_velocity_ref();

         AllegroFlare::Physics::AABB2D aabb2d(
            placement.position.x - box_h_size,
            placement.position.z - box_h_size,
            box_size, // Each object will have the size of the "box_size"
            box_size,
            velocity.position.x,
            velocity.position.z
         );

         collision_stepper.set_aabb2d(&aabb2d);

         std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo> stepper_step_result =
            collision_stepper.step();

         placement.position = AllegroFlare::Vec3D(
            aabb2d.get_x() + box_h_size,
            placement.position.y,
            aabb2d.get_y() + box_h_size
         );
         velocity.position = { aabb2d.get_velocity_x(), 0.0f, aabb2d.get_velocity_y() };
         placement.rotation += velocity.rotation;
      }

      update_entity_player_is_currently_colliding_with();

      // HACK: Extract out the camera and assign it's position
      // TODO: Create a separate entity, then assign the camera values to the live camera (or something)
      as_camera->AllegroFlare::Camera3D::position = as_camera->get_placement_ref().position;

      return;
    body_dependency_symbols:
      - ArtGalleryOfCats::Gameplay::Entities::Camera3D
      - AllegroFlare::Camera3D
      - AllegroFlare::Physics::TileMapCollisionStepper
      - ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap


  - name: render
    body: |
      scene_renderer_render();
      render_hud();
      return;


  - name: scene_renderer_render
    private: true
    guards: [ get_entity_pool() ]
    body: |
      ArtGalleryOfCats::Gameplay::SceneRenderer scene_renderer;
      scene_renderer.set_entity_pool(get_entity_pool());
      scene_renderer.set_cubemap_shader(&cubemap_shader);
      scene_renderer.render();
      return;
    body_dependency_symbols:
      - ArtGalleryOfCats::Gameplay::SceneRenderer


  - name: render_hud
    private: true
    guards: [ get_entity_pool() ]
    body: |
      // Local vars;
      AllegroFlare::SceneGraph::Entities::Base *entity = nullptr;

      AllegroFlare::Camera2D hud_camera;
      ALLEGRO_BITMAP *render_surface = al_get_backbuffer(al_get_current_display()); // TODO: replace with render surface
      hud_camera.setup_dimentional_projection(render_surface);

      hud_camera.position.x = -800;
      hud_camera.position.y = -400;

      hud_camera.start_reverse_transform();
      //hud_camera.start_transform();

      //ALLEGRO_FONT *font = al_create_builtin_font();
      //al_draw_text(font, ALLEGRO_COLOR{1, 1, 1, 1}, 10, 10, ALLEGRO_ALIGN_LEFT, ".ul");
      //al_draw_text(font, ALLEGRO_COLOR{1, 1, 1, 1}, 1920-10, 1080-10, ALLEGRO_ALIGN_RIGHT, "br.");


      // Render the mini-map
      bool render_mini_map = false;

      if (render_mini_map)
      {
         // Extract out the collision map
         ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap* as_collision_tile_map = find_collision_tile_map();
         AllegroFlare::TileMaps::TileMap<int> &collision_tile_map= as_collision_tile_map->get_collision_tile_map_ref();



         render_tile_map(&collision_tile_map, 16.0f, 16.0f);


         for (auto &entity : get_entity_pool()->get_entity_pool_ref())
         {
            ArtGalleryOfCats::Gameplay::Entities::Base *as_agc_entity =
               static_cast<ArtGalleryOfCats::Gameplay::Entities::Base*>(entity);
            AllegroFlare::Placement3D &placement = as_agc_entity->get_placement_ref();
            //AllegroFlare::Placement3D &velocity = as_agc_entity->get_velocity_ref();

            AllegroFlare::Physics::AABB2D aabb2d(
               placement.position.x * 16 - (16 * 0.5),
               placement.position.z * 16 - (16 * 0.5),
               16.0, // Our object will be a 1x1 square
               16.0
               //velocity.position.x,
               //velocity.position.z
            );

            render_aabb2d(
                     &aabb2d
                  );

            al_draw_filled_circle(placement.position.x * 16, placement.position.z * 16, 8, ALLEGRO_COLOR{0, 1, 0.8, 1.0});
         }
      }

      if (riddle_is_showing)
      {
         // TODO: Draw the riddle text;
         ALLEGRO_FONT* riddle_font = obtain_riddle_font();
         std::string riddle_text = get_current_riddle()->get_riddle_text();
         ALLEGRO_COLOR riddle_color = ALLEGRO_COLOR{1, 1, 1, 1};
         al_draw_multiline_text(
            riddle_font,
            riddle_color,
            -500,
            -200,
            1000,
            al_get_font_line_height(riddle_font) * 1.65,
            0,
            riddle_text.c_str()
         );
      }

      if (inspect_hint_is_showing)
      {
         float inspect_hint_x = 1920*0.5 - 170; // TODO: make this not-hard-coded dimension
         float inspect_hint_y = 1080*0.5 - 50; // TODO: make this not-hard-coded dimension
         float inspect_hint_radius = 30.0f;
         ALLEGRO_COLOR inspect_hint_backfill_color = al_color_html("024d83");
         ALLEGRO_COLOR inspect_hint_text_color = al_color_html("ffffff");
         ALLEGRO_FONT* inspect_hint_icon_font = obtain_inspect_hint_icon_font();
         ALLEGRO_FONT* inspect_hint_text_font = obtain_inspect_hint_text_font();

         // Draw the circle
         al_draw_filled_circle(inspect_hint_x, inspect_hint_y, inspect_hint_radius, inspect_hint_backfill_color);

         // Draw the "i" character
         al_draw_text(
            inspect_hint_icon_font,
            inspect_hint_text_color,
            inspect_hint_x,
            inspect_hint_y - al_get_font_line_height(inspect_hint_icon_font) * 0.5,
            ALLEGRO_ALIGN_CENTER,
            "i"
         );

         // Draw the "[I] Inspect key help text" character
         al_draw_text(
            inspect_hint_text_font,
            inspect_hint_text_color,
            inspect_hint_x + inspect_hint_radius * 1.3,
            inspect_hint_y - al_get_font_line_height(inspect_hint_text_font) * 0.5,
            ALLEGRO_ALIGN_LEFT,
            "Inspect"
         );
      }

      
      hud_camera.restore_transform();

      return;
    body_dependency_symbols:
      - AllegroFlare::Camera2D
      - ALLEGRO_FONT
      - al_color_html


  - name: render_tile_map
    parameters:
      - name: tile_map
        type: AllegroFlare::TileMaps::TileMap<int>*
        default_argument: nullptr
      - name: tile_width
        type: float 
        default_argument: 16.0f 
      - name: tile_height
        type: float 
        default_argument: 16.0f 
    guards: [ tile_map ]
    body: |
      if (!al_is_primitives_addon_initialized()) throw std::runtime_error("render_tile_map: primitives must be init");

      for (int y=0; y<tile_map->get_num_rows(); y++)
      {
         for (int x=0; x<tile_map->get_num_columns(); x++)
         {
            int tile_type = tile_map->get_tile(x, y);
            switch(tile_type)
            {
               case 0:
                 //al_draw_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    //ALLEGRO_COLOR{0.2, 0.2, 0.21, 0.21}, 1.0);
               break;

               case 1:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.65, 0.62, 0.6, 1.0});
               break;

               default:
                 //al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    //ALLEGRO_COLOR{0.8, 0.32, 0.4, 1.0});
               break;
            }
         }
      }
      return;


  - name: render_aabb2d
    parameters:
      - name: aabb2d
        type: AllegroFlare::Physics::AABB2D*
        default_argument: nullptr
      - name: adjacent_to_top_edge
        type: bool 
        default_argument: false
      - name: adjacent_to_right_edge
        type: bool 
        default_argument: false
      - name: adjacent_to_bottom_edge
        type: bool 
        default_argument: false
      - name: adjacent_to_left_edge
        type: bool 
        default_argument: false
    guards: [ aabb2d ]
    body: |
      al_draw_filled_rectangle(aabb2d->get_x(), aabb2d->get_y(), aabb2d->get_right_edge(), aabb2d->get_bottom_edge(),
         ALLEGRO_COLOR{1.0, 1.0, 1.0, 1.0});

      ALLEGRO_COLOR orange = ALLEGRO_COLOR{1.0, 0.5, 0.0, 1.0};

      /*
      if (adjacent_to_bottom_edge)
      {
         al_draw_line(aabb2d->get_x(), aabb2d->get_bottom_edge(), aabb2d->get_right_edge(), aabb2d->get_bottom_edge(), orange, 2.0);
      }
      if (adjacent_to_top_edge)
      {
         al_draw_line(aabb2d.get_x(), aabb2d.get_y(), aabb2d.get_right_edge(), aabb2d.get_y(), orange, 2.0);
      }
      if (adjacent_to_left_edge)
      {
         al_draw_line(aabb2d.get_x(), aabb2d.get_y(), aabb2d.get_x(), aabb2d.get_bottom_edge(), orange, 2.0);
      }
      if (adjacent_to_right_edge)
      {
         al_draw_line(aabb2d.get_right_edge(), aabb2d.get_y(), aabb2d.get_right_edge(), aabb2d.get_bottom_edge(), orange, 2.0);
      }
      */
      return;


  - name: call_on_finished_callback_func
    body: |
      // TODO: Test this callback call
      if (on_finished_callback_func) on_finished_callback_func(this, on_finished_callback_func_user_data);


  - name: primary_timer_func
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      update();
      render();
      return;


  - name: player_spin_change
    parameters:
      - name: delta
        type: float
        default_argument: 0.0f
    body: |
      ArtGalleryOfCats::Gameplay::Entities::Camera3D* as_camera = find_primary_camera();

      as_camera->spin += delta;
      return;


  - name: player_tilt_change
    parameters:
      - name: delta
        type: float
        default_argument: 0.0f
    body: |
      ArtGalleryOfCats::Gameplay::Entities::Camera3D* as_camera = find_primary_camera();

      //as_camera->tilt += delta;
      float tilt = as_camera->tilt;

      tilt += delta;
      float max_tilt = 3.14 / 2;
      if (tilt < -max_tilt) tilt = -max_tilt;
      if (tilt > max_tilt) tilt = max_tilt;
      as_camera->tilt = tilt;
      return;


  - name: player_stop_moving
    body: |
      player_up_pressed = false;
      player_down_pressed = false;
      player_left_pressed = false;
      player_right_pressed = false;
      player_velocity.x = 0;
      player_velocity.y = 0;
      return;


  - name: infer_player_velocity_from_keypress
    type: AllegroFlare::Vec2D
    body: |
      AllegroFlare::Vec2D result = { 0, 0 };
      float speed = 0.1;
   
      if (player_left_pressed && player_right_pressed) result.x = 0.0f;
      else if (player_left_pressed) result.x = -speed;
      else if (player_right_pressed) result.x = speed;

      if (player_up_pressed && player_down_pressed) result.y = 0.0f;
      else if (player_up_pressed) result.y = -speed;
      else if (player_down_pressed) result.y = speed;

      return result;


  - name: virtual_control_button_up_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |

      switch(virtual_controller_button_num)
      {
         case AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT: {
            player_left_pressed = false;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT: {
            player_right_pressed = false;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_UP: {
            player_up_pressed = false;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_DOWN: {
            player_down_pressed = false;
         } break;

         default: {
            // TODO: IMPORTANT: There is currently no escape from gameplay/screen
            //call_on_finished_callback_func();
         } break;
      };

      //player_stop_moving(); // TODO: Improve this movement
      return;


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      // TODO: validate virtual controller type

      switch(virtual_controller_button_num)
      {
         case AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT: {
            player_left_pressed = true;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT: {
            player_right_pressed = true;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_UP: {
            player_up_pressed = true;
         } break;

         case AllegroFlare::VirtualControllers::GenericController::BUTTON_DOWN: {
            player_down_pressed = true;
         } break;

         default: {
            // TODO: IMPORTANT: There is currently no escape from gameplay/screen
            //call_on_finished_callback_func();
         } break;
      };

      return;
    body_dependency_symbols:
      - AllegroFlare::VirtualControllers::GenericController


  - name: activate_npc_conversations_screen
    body: |
      event_emitter->emit_router_event(
         AllegroFlare::Routers::Standard::EVENT_ACTIVATE_SCREEN_BY_IDENTIFIER,
         new AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier("npc_conversations_screen")
      );
      return;


  - name: find_custom_dialog_for_this_inspect
    type: std::string
    parameters:
      - name: entity_inspecting_on
        type: AllegroFlare::SceneGraph::Entities::Base*
        default_argument: nullptr
    body: |
      if (!entity_inspecting_on) return "";

      std::string art_identifier = entity_inspecting_on->get(ArtGalleryOfCats::Gameplay::EntityFlags::ART_IDENTIFIER);

      std::string const INSPECT_PREFIX = "inspect_";

      std::cout << "Inspecting on \"" << art_identifier << "\"" << std::endl;
      if (art_identifier == "black_and_white_cats") return "inspect_on_black_and_white_cats_art";


      // These listed here will automatically return "inspect_[art_identifier]";
      std::set<std::string> special_inspect_to_return_with_inspect_prefix = {
         "medium_statue",
         "feature_statue",
         "small_statues",
         "human_01",
         "human_02",
         "human_03",
         "human_04",
         "human_05",
         "cat_years_to_human_years",
      };

      if (special_inspect_to_return_with_inspect_prefix.count(art_identifier) != 0)
      {
         return INSPECT_PREFIX + art_identifier;
      }


      // TODO: Add special case dialog here

      return "";


  - name: interact_with_focused_object
    guards: [ npc_conversations_screen ]
    body: |
      if (!entity_player_is_currently_colliding_with)
      {
         // TODO: play a sound that indicates there is nothing to interact with
         return;
      }

      player_stop_moving();


      std::string dialog_identifier_to_use = "fallback_dialog";

      std::string custom_dialog_identifier = find_custom_dialog_for_this_inspect(
         entity_player_is_currently_colliding_with
      );

      if (custom_dialog_identifier.empty())
      {
         // There is no custom dialog, so select a fallback dialog here

         static int last_default_inspect_index = 0;
         std::vector<std::string> default_inspect_dialog_node_identifiers = {
            "default_inspect_1",
            "default_inspect_2",
            "default_inspect_3",
            "default_inspect_4",
            "default_inspect_5",
            "default_inspect_6",
         };

         dialog_identifier_to_use = default_inspect_dialog_node_identifiers[last_default_inspect_index];

         last_default_inspect_index++;
         if (last_default_inspect_index >= default_inspect_dialog_node_identifiers.size()) last_default_inspect_index = 0;
      }
      else
      {
         dialog_identifier_to_use = custom_dialog_identifier;
      }




      //std::string defaut_dialog = "That is some beautiful art!";


      // TODO: Set the npc avatar for this dialog
      // TODO: Setup an npc name, and add it to this dialog
      // TODO: Set the text pages for this character dialog

      //std::vector<std::string> dialog_pages = {
         //"Impressive",
         //"The artist has such an amazing sense of form and balance!",
      //};


      
      //std::vector<AllegroFlare::Elements::StoryboardPages::Base *> storyboard_pages = {};
      //dialog_node_bank.
   

      //this_dialog_node_to_say


      /*
      // TODO: Clear pages on the storyboard element
      npc_conversations_screen->get_storyboard_element_ref().set_pages({
          create_image_page(
          //page_factory.create_advancing_text_page(
         "default_inspect_1",
            "Impressive!"
             //I guess I would be.",
            //"I really like all this art! It nourishes the spirit. It ignites the soul!"
          //),
          ),
          create_image_page(
          //page_factory.create_advancing_text_page(
             "The artist has such an amazing sense of form and balance!"
          ),
      });
      */


      activate_npc_dialog_by_identifier(dialog_identifier_to_use);



      //activate_npc_conversations_screen(); // DEVELOPMENT

      //event_emitter->talk_to_an_npc
      event_emitter->emit_event(
         ALLEGRO_FLARE_EVENT_UNLOCK_ACHIEVEMENT,
         intptr_t(new std::string("look_at_some_art"))
      );
      return;


  - name: attempt_to_solve_riddle
    guards: [ user_text_input_screen ]
    body: |
      player_stop_moving();

      // Set the prompt on the user text input screen
      // TODO: Make this value dynamic
      std::string riddle_prompt_text = get_current_riddle()->get_riddle_prompt_text();
      user_text_input_screen->set_prompt_text(riddle_prompt_text);

      // Clear our value
      last_user_text_input_value.clear();

      // TODO: setup the prompt screen with context

      event_emitter->emit_router_event(
         AllegroFlare::Routers::Standard::EVENT_ACTIVATE_SCREEN_BY_IDENTIFIER,
         new AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier("user_text_input_screen") // TODO: use constant
      );
      return;


  - name: toggle_riddle_visibility
    body: |
      riddle_is_showing = !riddle_is_showing;
      return;


  - name: hide_riddle
    body: |
      riddle_is_showing = false;
      return;


  - name: show_inspect_hint
    body: |
      inspect_hint_is_showing = true;
      return;


  - name: hide_inspect_hint
    body: |
      inspect_hint_is_showing = false;
      return;


  - name: virtual_control_axis_change_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized ]
    body: |
      //if (ev->mouse
      //result->tilt = 0.13;            // look up(-)/down(+)
      //result->spin = 0.2;             // set a good start initial spin
      // TODO: this function
      return;


  - name: emit_event_to_return_to_the_level_select_screen
    body: |
       event_emitter->emit_router_event(
          AllegroFlare::Routers::Standard::EVENT_ACTIVATE_LEVEL_SELECT_SCREEN,
          nullptr,
          al_get_time()
       );
       return;


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event_emitter ]
    body: |
      // This method is DEBUGGING
      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_UP: {
            player_up_pressed = true;
         } break;

         case ALLEGRO_KEY_LEFT: {
            player_left_pressed = true;
         } break;

         case ALLEGRO_KEY_DOWN: {
            player_down_pressed = true;
         } break;

         case ALLEGRO_KEY_RIGHT: {
            player_right_pressed = true;
         } break;

         case ALLEGRO_KEY_SPACE:
         case ALLEGRO_KEY_ENTER:
         case ALLEGRO_KEY_I: {
            interact_with_focused_object();
         } break;

         case ALLEGRO_KEY_S: {
            //interact_with_focused_object();
            attempt_to_solve_riddle();
         } break;

         case ALLEGRO_KEY_R: {
            toggle_riddle_visibility();
         } break;

         case ALLEGRO_KEY_ESCAPE: {
            emit_event_to_return_to_the_level_select_screen();
            //prompt_user_for_text_input(); // DEVELOPMENT
         } break;

         default: {
            // Nothing here
         } break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Routers::Standard
      - AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
      - AllegroFlare::EventNames


  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event_emitter ]
    body: |
      // This method is DEBUGGING
      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_W: {
            player_up_pressed = false;
         } break;

         case ALLEGRO_KEY_A: {
            player_left_pressed = false;
         } break;

         case ALLEGRO_KEY_S: {
            player_down_pressed = false;
         } break;

         case ALLEGRO_KEY_D: {
            player_right_pressed = false;
         } break;

         default: {
            // Nothing here
         } break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Routers::Standard
      - AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
      - AllegroFlare::EventNames


  - name: mouse_down_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized ]
    body: |
      //interact_with_focused_object();
      return;


  - name: mouse_axes_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized ]
    body: |
      // TODO: Validate spin change
      float spin_delta = ev->mouse.dx;
      float tilt_delta = ev->mouse.dy;
      float spin_multiplier = 0.001;
      float tilt_multiplier = 0.001;
      player_spin_change(spin_delta * spin_multiplier);
      player_tilt_change(tilt_delta * tilt_multiplier);


      // HACK
      ALLEGRO_DISPLAY *current_display = al_get_current_display();
      int current_display_flags = al_get_display_flags(current_display);
      bool this_display_is_fullscreen = current_display_flags & ALLEGRO_FULLSCREEN_WINDOW;
      bool this_display_is_windowed = !this_display_is_fullscreen;

      //if (this_display_is_fullscreen)
      //{
         //throw std::runtime_error("this_display_is_fullscreen");
      //}
      //else
      //{
         //throw std::runtime_error("this_display_is_not_fullscreen");
      //}


      //ALLEGRO_FULLSCREEN_WINDOW

      bool this_system_is_a_mac = (HACK_sysname == "Darwin");

      if (this_display_is_windowed && this_system_is_a_mac)
      {
         if (current_display)
         {
            al_set_mouse_xy(
               current_display,
               al_get_display_width(current_display)*0.5,
               al_get_display_height(current_display)*0.5
            );
         }
      }

      if (!this_display_is_windowed && !this_system_is_a_mac)
      {
         // Warp on windows in fullscreen
         if (current_display)
         {
            al_set_mouse_xy(
               current_display,
               al_get_display_width(current_display)*0.5,
               al_get_display_height(current_display)*0.5
            );
         }
      }


      //float x_delta = ev->mouse->dx;
      //result->tilt = 0.13;            // look up(-)/down(+)
      //result->spin = 0.2;             // set a good start initial spin
      // TODO: this function
      return;


  - name: create_image_page
    parameters:
      - name: text
        type: std::string
        default_argument: '"[unset-text]"'
    type: AllegroFlare::Elements::StoryboardPages::ImageWithAdvancingText*
    body: |
      AllegroFlare::Elements::StoryboardPages::ImageWithAdvancingText *result =
         new AllegroFlare::Elements::StoryboardPages::ImageWithAdvancingText();
      result->set_bitmap_bin(bitmap_bin);
      result->set_font_bin(font_bin);
      result->set_text(text);
      result->set_font_size(-50);
      result->set_line_height_multiplier(1.25f);
      result->set_image_fade_in_duration_sec(0.0f);
      result->set_text_color(ALLEGRO_COLOR{0, 0, 0, 1});
      result->set_image_identifier("character-avatar-01.png");
      //"storyboard-1-01-1165x500.png");
      result->set_top_padding(650);
      result->set_left_padding(600);
      result->set_right_padding(600);
      return result;
    body_dependency_symbols:
      - ALLEGRO_COLOR


  - name: obtain_riddle_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("BodoniModa_9pt-SemiBold.ttf -72");


  - name: obtain_inspect_hint_icon_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("BodoniModa_9pt-SemiBold.ttf -72");


  - name: obtain_inspect_hint_text_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("BodoniModa_9pt-SemiBold.ttf -48");


dependencies:


  - symbol: AllegroFlare::Elements::StoryboardPages::ImageWithAdvancingText
    headers: [ AllegroFlare/Elements/StoryboardPages/ImageWithAdvancingText.hpp ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::ModelBin
    headers: [ AllegroFlare/ModelBin.hpp ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::Player
    headers: [ AllegroFlare/Player.hpp ]
  - symbol: AllegroFlare::VirtualControllers::Base
    headers: [ AllegroFlare/VirtualControllers/Base.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Screen
    headers: [ ArtGalleryOfCats/Gameplay/Screen.hpp ]
  - symbol: AllegroFlare::SceneGraph::EntityPool
    headers: [ AllegroFlare/SceneGraph/EntityPool.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::EntityFactory
    headers: [ ArtGalleryOfCats/Gameplay/EntityFactory.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Entities::Base
    headers: [ ArtGalleryOfCats/Gameplay/Entities/Base.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Entities::Camera3D
    headers: [ ArtGalleryOfCats/Gameplay/Entities/Camera3D.hpp ]
  - symbol: AllegroFlare::VirtualControllers::GenericController
    headers: [ AllegroFlare/VirtualControllers/GenericController.hpp ]
  - symbol: AllegroFlare::Physics::TileMapCollisionStepper
    headers: [ AllegroFlare/Physics/TileMapCollisionStepper.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: AllegroFlare::Camera3D
    headers: [ AllegroFlare/Camera3D.hpp ]
  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: AllegroFlare::Physics::AABB2D
    headers: [ AllegroFlare/Physics/AABB2D.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::LevelFactory
    headers: [ ArtGalleryOfCats/Gameplay/LevelFactory.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Entities::CollisionTileMap
    headers: [ ArtGalleryOfCats/Gameplay/Entities/CollisionTileMap.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::SceneRenderer
    headers: [ ArtGalleryOfCats/Gameplay/SceneRenderer.hpp ]
  - symbol: AllegroFlare::Shaders::Cubemap
    headers: [ AllegroFlare/Shaders/Cubemap.hpp ]
  - symbol: AllegroFlare::Cubemap
    headers: [ AllegroFlare/Cubemap.hpp ]
  - symbol: AllegroFlare::CubemapBuilder
    headers: [ AllegroFlare/CubemapBuilder.hpp ]
  - symbol: AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
    headers: [ AllegroFlare/RouteEventDatas/ActivateScreenByIdentifier.hpp ]
  - symbol: AllegroFlare::Routers::Standard
    headers: [ AllegroFlare/Routers/Standard.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: AllegroFlare::Vec3D
    headers: [ AllegroFlare/Vec3D.hpp ]
  - symbol: AllegroFlare::SceneGraph::Entities::Base
    headers: [ AllegroFlare/SceneGraph/Entities/Base.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::EntityFlags
    headers: [ ArtGalleryOfCats/Gameplay/EntityFlags.hpp ]
  - symbol: ArtGalleryOfCats::Screens::UserTextInput
    headers: [ ArtGalleryOfCats/Screens/UserTextInput.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Riddle
    headers: [ ArtGalleryOfCats/Gameplay/Riddle.hpp ]
  - symbol: ArtGalleryOfCats::Gameplay::Level
    headers: [ ArtGalleryOfCats/Gameplay/Level.hpp ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: al_color_html
    headers: [ allegro5/allegro_color.h ]
  - symbol: AllegroFlare::Screens::Storyboard
    headers: [ AllegroFlare/Screens/Storyboard.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]


